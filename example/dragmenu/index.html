<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Regular.js â€¢ dragmenu</title>
    <link rel="stylesheet" href="http://getbootstrap.com/dist/css/bootstrap.min.css">
    <script src="../../dist/regular.js"></script>
    <script src="drag.js"></script>
    <style>
    </style>
  </head>
  <body>

    <div id="app">
      <div class="m-screen">
        <div id="container" class='container'>
        </div>
      </div>
    </div>

    <!-- Templates -->
    <script id="menu" type="text/regular" name='menu'>
      <ul class='m-menu m-menu-{{this.count()}} clearfix' >
        {{#list menus as menu}}
          <li class='m-smenu u-menu {{menu.drag? "drag": ""}}'  >
            <a href="#"  on-click={{ this.toggleShow(menu) }}  on-drag={{this.drag($index, menus, $event)}}>{{menu.name}}</a><span class='close' on-click={{this.remove(menu, menus)}}>x</span>
            <ul r-hide={{!menu.show ||  this.draged}}>
              <li r-hide={{menu.children.length > this.maxSubMenu}} class='u-menu'>
                <a href='#' on-click={{this.add(menu.children)}}> + </a> 
              </li>
              {{#list menu.children as smenu }}
                <li class={{smenu.drag? "drag": ""}}><a href="#" on-drag={{this.drag($index, menu.children, $event)}}>{{smenu.name}}</a><span class='close' on-click={{this.remove(smenu, menu.children)}} >x</span>
                </li>
              {{/list}}
            </ul>
          </li>
        {{/list}}
        <li class='u-menu' r-hide={{menus.length >= this.maxMenu}} on-click={{this.add()}}><a href='#'> + </a> </li>
        {{#if this.draged}}<li  class="u-drag u-menu" style="width: {{this.totalWidth/this.count() + 'px'}}; left: {{(this.deltaX || 0) + 'px'}}; top: {{(this.deltaY || 0) + 'px'}}"> <a>{{this.draged && this.draged.name}}</a> </li>  {{/if}}
      </ul>
    </script>

    
    <script>
    function getRect(elem){
      var docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft,
        box = { top: 0, left: 0 },
        doc = elem && elem.ownerDocument,win = window, body = doc.body;

      if ( !doc ) return;
      docElem = doc.documentElement;

      if ( typeof elem.getBoundingClientRect !== "undefined" ) {
        box = elem.getBoundingClientRect();
      }

      clientTop  = docElem.clientTop  || body.clientTop  || 0;
      clientLeft = docElem.clientLeft || body.clientLeft || 0;
      scrollTop  = win.pageYOffset || docElem.scrollTop;
      scrollLeft = win.pageXOffset || docElem.scrollLeft;

      return {
        top: box.top  + scrollTop  - clientTop,
        left: box.left + scrollLeft - clientLeft
      };
    }
    // swap data

    // event.stopImmediatePropagation
    var dom = Regular.dom;
    var Menu = Regular.extend({
      template: '#menu',
      config: function(){
        this.maxMenu = 4;
        this.maxSubMenu = 5;
        this.totalWidth = 320;
        this.height = 34;
      },
      init: function(){

      },
      drag: function(index, container, ev){

        switch(ev.type){
          case 'dragstart':
            if(!this.base) this.base = getRect(this.element);
            var rect = getRect(ev.target);
            this.index = index;
            this.offset = {x: rect.left - this.base.left, y: rect.top - this.base.top, pageX: ev.pageX, pageY: ev.pageY, left: rect.left, top: rect.top}
            var item = container[index];
            this.deltaX = this.offset.x;
            this.deltaY = this.offset.y;
            this.draged = item;
            // this.draged.drag = true;
            this.index = index;
            break;
          case 'dragmove':
            var deltaX = ev.pageX -  this.offset.left;
            var deltaY = ev.pageY -  this.offset.top;
            var delta = this.draged.children? deltaX / this.totalWidth * this.count() : deltaY / this.height ;

            
            delta = Math.floor(delta)
            if(this.draged.children){
              this.deltaX = ev.pageX - this.offset.pageX +  this.offset.x;
            }else{
              this.deltaY = ev.pageY - this.offset.pageY  + this.offset.y;
            }
            var indx = container.indexOf(this.draged);
            var cursor = Math.max( 0, Math.min(this.index + delta, container.length - 1 ));
            if(cursor !== indx){
               this.swap(container, indx, cursor );;
            }
            break;
          case 'dragend':
            this.draged.drag = false;
            this.index = '';
            this.draged = null;
        }
      },
      // menus count
      count: function(){
        var data = this.data;
        return data.menus.length >= this.maxMenu? this.maxMenu: data.menus.length + 1;
      },
      remove: function(item, list){
        var index= list.indexOf(item)
        if(~index) list.splice(index,1);

      },
      edit: function(menu){
        console.log(menu);
      },
      toggleShow: function(menu){
        var data = this.data;
        var flag = !menu.show;
        if(flag){
          data.menus.forEach(function(menu){
            menu.show = false;
          })
        }
        menu.show = flag;
      },
      add: function(container){
        if(container){
          container.unshift({name:'smenu' + container.length})
        }else{
          this.data.menus.push({name: 'menu' + this.data.menus.length, children: []})
        }
      },
      swap:function(container, index1, index2){
        var tmp = container[index1];
        container.splice(index1, 1)
        container.splice(index2,0, tmp)
      }
    });


    var app =new Menu({
      data:{
        menus: [
          {name: 'menu0', children:[]},
          {name: 'menu1', children:[]}
        ]}
      }
     ).inject('#container')
    </script>



    
  </body>
</html>
